using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using SAModel;
using SplitTools;
using System.Linq;
using static UniversalSplit;

public class UniversalSplit
{
	public struct ItemDescriptor
	{
		public string ObjectType;
		public string ObjectName;
	}
	public struct ItemParams
	{
		public int IntParam;
		public string StringParam;
		public bool BoolParam;
	}
	private static bool LabelIsAutoGenerated(string label)
	{
		string[] labelstart = {
				"action_",
				"animation_",
				"object_",
				"attach_",
				"uv_",
				"polynormal_",
				"poly_",
				"matlist_",
				"meshlist_",
				"vertex_",
				"vcolor_",
				"normal_",
			};
		for (int u = 0; u < labelstart.Length; u++)
		{
			if (label.Length < labelstart[u].Length + 8) continue;
			if (label.Substring(0, labelstart[u].Length) == labelstart[u])
			{
				string after = label.Substring(labelstart[u].Length, label.Length - labelstart[u].Length);
				if (after.Length == 8 && int.TryParse(after, NumberStyles.AllowHexSpecifier, null, out _) == true) return true;
				if (after.Length == 19)
				{
					if (System.Text.RegularExpressions.Regex.IsMatch(after, @"\A\b[0-9a-fA-F]+\b\Z")) return true;
				}
			}
		}
		return false;
	}
	public static void ExportLabels(LandTable land, string path, Dictionary<string, int> labelindex)
	{
		if (labelindex.ContainsKey(land.Name)) return;
		Label_LANDTABLE desc = new Label_LANDTABLE();
		if (!LabelIsAutoGenerated(land.Name)) desc.LandtableName = land.Name;
		if (land.COL != null && land.COL.Count > 0)
		{
			if (!LabelIsAutoGenerated(land.COLName)) desc.COLListName = land.COLName;
			COL[] colarray = land.COL.ToArray();
			desc.ColItemNames = new string[colarray.Length];
			for (int u = 0; u < colarray.Length; u++)
			{
				desc.ColItemNames[u] = colarray[u].Model.Name;
			}
			foreach (COL col in land.COL)
			{
				ExportLabels(col.Model, path, labelindex);
			}
		}
		if (land.Anim != null && land.Anim.Count > 0)
		{
			if (!LabelIsAutoGenerated(land.AnimName)) desc.GeoAnimListName = land.AnimName;
			GeoAnimData[] geoanimarray = land.Anim.ToArray();
			desc.GeoAnimObjectNames = new string[geoanimarray.Length];
			desc.GeoAnimActionNames = new string[geoanimarray.Length];
			for (int u = 0; u < geoanimarray.Length; u++)
			{
				desc.GeoAnimObjectNames[u] = geoanimarray[u].Model.Name;
				desc.GeoAnimActionNames[u] = geoanimarray[u].ActionName;
			}
			foreach (GeoAnimData geo in land.Anim)
			{
				ExportLabels(geo.Model, path, labelindex);
				ExportLabels(geo.Animation, path, labelindex);
			}
		}
		IniSerializer.Serialize(desc, Path.Combine(path, labelindex.Count + ".txt"));
		labelindex.Add(land.Name, labelindex.Count);
	}
	public static void ExportLabels(NJS_ACTION action, string path, Dictionary<string, int> labelindex)
	{
		if (labelindex.ContainsKey(action.Name)) return;
		Label_ACTION desc = new Label_ACTION();
		if (!LabelIsAutoGenerated(action.Name)) desc.ActionName = action.Name;
		if (!LabelIsAutoGenerated(action.Animation.Name)) desc.MotionName = action.Animation.Name;
		if (!LabelIsAutoGenerated(action.Model.Name)) desc.ObjectName = action.Model.Name;
		IniSerializer.Serialize(desc, Path.Combine(path, labelindex.Count + ".txt"));
		labelindex.Add(action.Name, labelindex.Count);
		if (action.Animation != null && !LabelIsAutoGenerated(action.Animation.Name)) ExportLabels(action.Animation, path, labelindex);
		if (action.Model != null && !LabelIsAutoGenerated(action.Model.Name)) ExportLabels(action.Model, path, labelindex);
	}
	public static void ExportLabels(NJS_MOTION mot, string path, Dictionary<string, int> labelindex)
	{
		if (labelindex.ContainsKey(mot.Name)) return;
		Label_MOTION desc = new Label_MOTION();
		if (!LabelIsAutoGenerated(mot.Name)) desc.MotionName = mot.Name;
		if (mot.Models != null)
		{
			if (!LabelIsAutoGenerated(mot.MdataName)) desc.MdataName = mot.MdataName;
			desc.MkeyNames = new Dictionary<int, Label_MKEY>();
			foreach (var item in mot.Models)
			{
				Label_MKEY mkey = new Label_MKEY();
				if (item.Value.Position.Count > 0)
					mkey.PositionName = item.Value.PositionName;
				if (item.Value.Rotation.Count > 0)
					mkey.RotationName = item.Value.RotationName;
				if (item.Value.Scale.Count > 0)
					mkey.ScaleName = item.Value.ScaleName;
				if (item.Value.Vertex.Count > 0)
				{
					mkey.VertexName = item.Value.VertexName;
					mkey.VertexItemNames = new string[item.Value.VertexItemName.Length];
					for (int u = 0; u < item.Value.VertexItemName.Length; u++)
					{
						mkey.VertexItemNames[u] = item.Value.VertexItemName[u];
					}
				}
				if (item.Value.Normal.Count > 0)
				{
					mkey.NormalName = item.Value.NormalName;
					mkey.NormalItemNames = new string[item.Value.NormalItemName.Length];
					for (int u = 0; u < item.Value.NormalItemName.Length; u++)
					{
						mkey.NormalItemNames[u] = item.Value.NormalItemName[u];
					}
				}
				if (item.Value.Vector.Count > 0)
					mkey.VectorName = item.Value.VectorName;
				if (item.Value.Angle.Count > 0)
					mkey.AngleName = item.Value.AngleName;
				if (item.Value.Roll.Count > 0)
					mkey.RollName = item.Value.RollName;
				if (item.Value.Intensity.Count > 0)
					mkey.IntensityName = item.Value.IntensityName;
				if (item.Value.Point.Count > 0)
					mkey.PointName = item.Value.PointName;
				if (item.Value.Target.Count > 0)
					mkey.TargetName = item.Value.TargetName;
				if (item.Value.Color.Count > 0)
					mkey.ColorName = item.Value.ColorName;
				if (item.Value.Spot.Count > 0)
					mkey.SpotName = item.Value.SpotName;
				desc.MkeyNames.Add(item.Key, mkey);
			}
		}
		IniSerializer.Serialize(desc, Path.Combine(path, labelindex.Count + ".txt"));
		labelindex.Add(mot.Name, labelindex.Count);
	}
	public static void ExportLabels(NJS_OBJECT mdl, string path, Dictionary<string, int> labelindex)
	{
		if (labelindex.ContainsKey(mdl.Name)) return;
		Label_OBJECT desc = new Label_OBJECT();
		if (!LabelIsAutoGenerated(mdl.Name)) desc.ObjectName = mdl.Name;
		if (mdl.Attach != null)
		{
			if (!LabelIsAutoGenerated(mdl.Attach.Name)) desc.AtachName = mdl.Attach.Name;
			if (mdl.Attach is BasicAttach)
			{
				BasicAttach attach = (BasicAttach)mdl.Attach;
				if (attach.Vertex != null && !LabelIsAutoGenerated(attach.VertexName)) desc.VertexName = attach.VertexName;
				if (attach.Normal != null && !LabelIsAutoGenerated(attach.NormalName)) desc.NormalName = attach.NormalName;
				if (attach.Material != null && !LabelIsAutoGenerated(attach.MaterialName)) desc.MaterialName = attach.MaterialName;
				if (attach.Mesh != null && attach.Mesh.Count > 0)
				{
					if (!LabelIsAutoGenerated(attach.MeshName)) desc.MeshsetOrPolyName = attach.MeshName;
					desc.MeshsetItemNames = new Label_MESHSET[attach.Mesh.Count];
					NJS_MESHSET[] mesharray = attach.Mesh.ToArray();
					for (int u = 0; u < mesharray.Length; u++)
					{
						if (mesharray[u].Poly != null && !LabelIsAutoGenerated(mesharray[u].PolyName)) desc.MeshsetItemNames[u].PolyName = mesharray[u].PolyName;
						if (mesharray[u].UV != null && !LabelIsAutoGenerated(mesharray[u].UVName)) desc.MeshsetItemNames[u].UVName = mesharray[u].UVName;
						if (mesharray[u].PolyNormal != null && !LabelIsAutoGenerated(mesharray[u].PolyNormalName)) desc.MeshsetItemNames[u].PolyNormalName = mesharray[u].PolyNormalName;
						if (mesharray[u].VColor != null && !LabelIsAutoGenerated(mesharray[u].VColorName)) desc.MeshsetItemNames[u].VColorName = mesharray[u].VColorName;
					}
				}
			}
			else if (mdl.Attach is ChunkAttach)
			{
				ChunkAttach attach = (ChunkAttach)mdl.Attach;
				if (attach.Vertex != null && !LabelIsAutoGenerated(attach.VertexName)) desc.VertexName = attach.VertexName;
				if (attach.Poly != null && !LabelIsAutoGenerated(attach.PolyName)) desc.MeshsetOrPolyName = attach.PolyName;
			}
		}
		if (mdl.Children != null && mdl.Children.Count > 0)
		{
			NJS_OBJECT[] childarray = mdl.Children.ToArray();
			desc.ChildNames = new string[mdl.Children.Count];
			for (int u = 0; u < mdl.Children.Count; u++)
			{
				desc.ChildNames[u] = childarray[u].Name;
				ExportLabels(childarray[u], path, labelindex);
			}
		}
		if (mdl.Sibling != null)
		{
			desc.SiblingName = mdl.Sibling.Name;
			ExportLabels(mdl.Sibling, path, labelindex);
		}
		IniSerializer.Serialize(desc, Path.Combine(path, labelindex.Count + ".txt"));
		labelindex.Add(mdl.Name, labelindex.Count);
	}
	private static int FindNextItemAddress(Dictionary<int, ItemDescriptor> addresslist, int address)
	{
		int entry = addresslist.Keys.ToList().IndexOf(address);
		return addresslist.Keys.ToList()[entry + 1];
	}
	public static void SplitListToINI(Dictionary<int, ItemDescriptor> addresslist, string filename, Game game, uint imageBase, bool bigendian, bool reverse, int address, List<string> deleteditems, Dictionary<string, ItemParams> itemparamslist)
	{
		Console.WriteLine("Creating split INI file: {0}", filename);
		StreamWriter sw = File.CreateText(filename);
		sw.WriteLine("key=" + imageBase.ToString("X8"));
		if (Path.GetExtension(filename).ToLowerInvariant() == ".prs") sw.WriteLine("compressed=true");
		sw.WriteLine("game=" + game.ToString());
		if (bigendian) sw.WriteLine("bigendian=true");
		if (reverse) sw.WriteLine("reverse=true");
		if (address != 0) sw.WriteLine("offset=" + address.ToString("X8"));
		foreach (var entry in addresslist)
		{
			ItemDescriptor v = entry.Value;
			if (deleteditems.Contains(v.ObjectName)) continue;
			//Console.WriteLine("Adding object {0}", v.ObjectName);
			switch (v.ObjectType)
			{
				case "NJS_MOTION":
					if (!itemparamslist.ContainsKey(v.ObjectName)) continue;
					sw.WriteLine("[" + entry.Key.ToString("X8") + "]");
					sw.WriteLine("type=animation");
					sw.WriteLine("address=" + entry.Key.ToString("X8"));
					sw.WriteLine("numparts=" + itemparamslist[v.ObjectName].IntParam.ToString());
					if (itemparamslist[v.ObjectName].BoolParam)
						sw.WriteLine("shortrot=true");
					sw.WriteLine("filename=motions/" + v.ObjectName + ".saanim");
					break;
				case "NJS_ACTION":
					if (!itemparamslist.ContainsKey(v.ObjectName)) continue;
					sw.WriteLine("[" + entry.Key.ToString("X8") + "]");
					sw.WriteLine("type=action");
					sw.WriteLine("address=" + entry.Key.ToString("X8"));
					sw.WriteLine("filename=actions/" + v.ObjectName + ".saanim");
					sw.WriteLine("model=" + itemparamslist[v.ObjectName].StringParam);
					break;
				case "NJS_GC_OBJECT":
				case "gcobj":
					sw.WriteLine("[" + entry.Key.ToString("X8") + "]");
					sw.WriteLine("type=gcmodel");
					sw.WriteLine("address=" + entry.Key.ToString("X8"));
					sw.WriteLine("filename=gcmodels/" + v.ObjectName + ".sa2bmdl");
					break;
				case "NJS_CNK_OBJECT":
				case "cnkobj":
					sw.WriteLine("[" + entry.Key.ToString("X8") + "]");
					sw.WriteLine("type=chunkmodel");
					sw.WriteLine("address=" + entry.Key.ToString("X8"));
					sw.WriteLine("filename=chunkmodels/" + v.ObjectName + ".sa2mdl");
					break;
				case "NJS_OBJECT":
				case "obj":
					sw.WriteLine("[" + entry.Key.ToString("X8") + "]");
					if (game == Game.SADX) sw.WriteLine("type=basicdxmodel");
					else sw.WriteLine("type=basicmodel");
					sw.WriteLine("address=" + entry.Key.ToString("X8"));
					sw.WriteLine("filename=basicmodels/" + v.ObjectName + ".sa1mdl");
					if (itemparamslist.ContainsKey(v.ObjectName) && itemparamslist[v.ObjectName].StringParam != null && itemparamslist[v.ObjectName].StringParam != "")
					{
						sw.WriteLine("animations=" + itemparamslist[v.ObjectName].StringParam);
					}
					break;
				case "landtable":
				case "LandTable":
				case "_OBJ_LANDTABLE":
					sw.WriteLine("[" + entry.Key.ToString("X8") + "]");
					sw.WriteLine("type=landtable");
					sw.WriteLine("address=" + entry.Key.ToString("X8"));
					sw.WriteLine("filename=levels/" + v.ObjectName + ".sa1lvl");
					break;
			}
		}
		sw.Flush();
		sw.Close();
	}
	public static void ParseDictionary(Dictionary<int, ItemDescriptor> addresslist, Dictionary<int, string> labellist, string listpath, bool skip)
	{
		using (var fileStream = File.OpenRead(listpath))
		using (var streamReader = new StreamReader(fileStream, System.Text.Encoding.UTF8, true, 512))
		{
			String line;
			while ((line = streamReader.ReadLine()) != null)
			{
				String[] arr = line.Split(',');
				int value = int.Parse(arr[0], NumberStyles.AllowHexSpecifier);
				if (arr.Length > 2)
				{
					string type = arr[1];
					string name = arr[2];
					if (!addresslist.ContainsKey(value))
					{
						if (!skip)
						{
							addresslist.Add(value, new ItemDescriptor { ObjectType = type, ObjectName = name });
							if (labellist != null) labellist.Add(value, name);
						}
						else addresslist.Add(value, new ItemDescriptor { ObjectType = type, ObjectName = name });
						//Console.WriteLine("Added key {0} value {1}", value.ToString("X"), arr[arr.Length - 1]);
					}
				}
				else if (arr.Length > 1)
				{
					if (!skip && !addresslist.ContainsKey(value))
					{
						string name = arr[1];
						addresslist.Add(value, new ItemDescriptor { ObjectType = "NULL", ObjectName = "NULL" });
						if (labellist != null) labellist.Add(value, name);
						//Console.WriteLine("Added key {0} value {1}", value.ToString("X"), arr[arr.Length - 1]);
					}
				}
			}
		}
	}
	/// <summary>
	/// Splits a single item of a specified type to a file.
	/// </summary>
	/// <param name="game">Game type</param>
	/// <param name="filename">Binary filename, e.g. sonic.exe</param>
	/// <param name="imageBase">Binary key, e.g. 0x400000</param>
	/// <param name="type">Type of split item. One of the following:
	/// <br/>| action | animation | animmdl | motion | basicdxmodel | basicmodel | chunkmodel | gcmodel | landtable | model 
	/// <br/>| deathzone | endpos | fieldstartpos | levelclearflags | levelrankscores | levelranktimes | startpos | storysequence | texnamearray | animindexlist | 
	/// <br/>| bmitemattrlist | creditstextlist | leveltexlist | objlist | pathlist | soundlist | soundtestlist | stagelightdatalist | texlist | weldlist 
	/// <br/>| bosslevellist | levelpathlist | nextlevellist | triallevellist | animationlist | sa1actionlist | enemyanimationlist | cutscenetext | masterstringlist | musiclist | npctext | recapscreen 
	/// <br/>| skyboxscale | stageselectlist | stringarray | list | binary | 
	/// </param>
	/// <param name="address">Address of the item in the binary</param>
	/// <param name="boolparam">Boolean parameter: 
	/// <br/>animation, animmdl, motion: use short rotations</param>
	/// <param name="intparam">Integer parameter: 
	/// <br/>animation: address of the NJS_OBJECT
	/// <br/>animmdl: model filename
	/// <br/>motion: node count
	/// <br/>binary: length in bytes
	/// <br/>musiclist, stringarray, cutscenetext, recapscreen, npctext, skyboxscale, stageselectlist, animationlist, sa1actionlist, enemyanimationlist, masterstringlist: item count
	/// </param>
	/// <param name="stringparam">String parameter:
	/// <br/>list: path to list
	/// <br/>animmdl: path to a model file
	/// <br/>stringarray: language, e.g. "English"</param>
	/// <param name="name">Output filename</param>
	/// <param name="bigendian">Enable Big Endian</param>
	/// <param name="reverse">Enable Reversed Big Endian (for X360 binaries)</param>
	public static void SplitSingle(Game game, string filename, uint imageBase, string type, int address, bool boolparam = false, int intparam = 0, string stringparam = "", string name = "", bool bigendian = false, bool reverse = false)
	{
		string dir = Environment.CurrentDirectory;
		string model_extension = ".sa1mdl";
		string landtable_extension = ".sa1lvl";
		ByteConverter.BigEndian = SAModel.ByteConverter.BigEndian = bigendian;
		ByteConverter.Reverse = SAModel.ByteConverter.Reverse = reverse;
		byte[] datafile = File.ReadAllBytes(filename);
		if (Path.GetExtension(filename).ToLowerInvariant() == ".prs") datafile = FraGag.Compression.Prs.Decompress(datafile);
		if (Path.GetExtension(filename).ToLowerInvariant() == ".rel") HelperFunctions.FixRELPointers(datafile, 0xC900000);
		Environment.CurrentDirectory = Path.Combine(Environment.CurrentDirectory, Path.GetDirectoryName(filename));
		bool SA2 = game == Game.SA2 | game == Game.SA2B;
		ModelFormat modelfmt = ModelFormat.BasicDX;
		LandTableFormat landfmt = LandTableFormat.SADX;
		switch (game)
		{
			case Game.SA1:
				modelfmt = ModelFormat.Basic;
				landfmt = LandTableFormat.SA1;
				model_extension = ".sa1mdl";
				landtable_extension = ".sa1lvl";
				break;
			case Game.SADX:
				modelfmt = ModelFormat.BasicDX;
				landfmt = LandTableFormat.SADX;
				model_extension = ".sa1mdl";
				landtable_extension = ".sa1lvl";
				break;
			case Game.SA2:
				modelfmt = ModelFormat.Chunk;
				landfmt = LandTableFormat.SA2;
				model_extension = ".sa2mdl";
				landtable_extension = ".sa2lvl";
				break;
			case Game.SA2B:
				modelfmt = ModelFormat.GC;
				landfmt = LandTableFormat.SA2B;
				model_extension = ".sa2bmdl";
				landtable_extension = ".sa2blvl";
				break;
		}
		Dictionary<string, MasterObjectListEntry> masterobjlist = new Dictionary<string, MasterObjectListEntry>();
		Dictionary<string, Dictionary<string, int>> objnamecounts = new Dictionary<string, Dictionary<string, int>>();
		string fileOutputPath = dir + "\\" + address.ToString("X");
		Console.Write("Game: {0}, file: {1}, key: 0x{2}, splitting {3} at 0x{4}", game.ToString(), filename, imageBase.ToString("X"), type, address.ToString("X"));
		if (name != "")
		{
			fileOutputPath = dir + "\\" + name;
			Console.Write(", name: {0}", name);
		}
		Console.Write(System.Environment.NewLine);
		try
		{
			switch (type.ToLowerInvariant())
			{
				case "list":
					byte[] data;
					//Start offset
					if (address != 0)
					{
						byte[] datafile_new = new byte[address + datafile.Length];
						datafile.CopyTo(datafile_new, address);
						data = datafile_new;
					}
					else data = datafile;
					bool skiplabels = false;
					bool noanims = false;
					/*if (args.Length > 6)
					{
						if (args[args.Length - 1] == "-skiplabels" || args[args.Length - 2] == "-skiplabels") skiplabels = true;
						if (args[args.Length - 1] == "-noanims") noanims = true;
					}*/
					Dictionary<int, ItemDescriptor> addresslist = new Dictionary<int, ItemDescriptor>(); //Main list of addresses, types and labels
					Dictionary<int, string> labellist = new Dictionary<int, string>(); //List of labels for creating objects in SA Tools
					Dictionary<string, int> labelindex = new Dictionary<string, int>(); //List of object names and matching indices in label match list
					Dictionary<string, List<string>> actionlist = new Dictionary<string, List<string>>(); //List of actions to tell which motions to assign/delete later
					List<LandTable> landlist = new List<LandTable>(); //List of landtables to tell which objects/animations to delete later
					List<string> deleteditems = new List<string>(); //List of items not to put in the split INI
					List<NJS_MOTION> motionslist = new List<NJS_MOTION>(); //List of motions for action assignment
					Dictionary<string, ItemParams> itemparamlist = new Dictionary<string, ItemParams>(); //List of object parameters such as node count for motions
					ParseDictionary(addresslist, labellist, stringparam, skiplabels);
					Directory.CreateDirectory(dir + "\\gcmodels");
					Directory.CreateDirectory(dir + "\\chunkmodels");
					Directory.CreateDirectory(dir + "\\basicmodels");
					Directory.CreateDirectory(dir + "\\labels");
					Directory.CreateDirectory(dir + "\\levels");
					Directory.CreateDirectory(dir + "\\actions");
					Directory.CreateDirectory(dir + "\\motions");
					//Scan for motions first
					foreach (var entry in addresslist)
					{
						ItemDescriptor v = entry.Value;
						if (v.ObjectType == "NJS_MOTION")
						{
							if (noanims) continue;
							fileOutputPath = dir + "\\motions\\" + v.ObjectName + ".saanim";
							Console.WriteLine("Splitting {0} {1} at {2}", v.ObjectType, v.ObjectName, entry.Key.ToString("X"));
							try
							{
								int mdataarraypointer = ByteConverter.ToInt32(data, int.Parse(entry.Key.ToString("X"), NumberStyles.AllowHexSpecifier)) - (int)imageBase;
								if (addresslist.ContainsKey(mdataarraypointer))
								{
									ItemDescriptor v2 = new ItemDescriptor();
									addresslist.TryGetValue(mdataarraypointer, out v2);
									int nextitem = FindNextItemAddress(addresslist, mdataarraypointer);
									int size = nextitem - (mdataarraypointer);
									int divide = 16;
									if (v2.ObjectType == "NJS_MDATA2") divide = 16;
									else if (v2.ObjectType == "NJS_MDATA3") divide = 24;
									else if (v2.ObjectType == "NJS_MDATA4") divide = 32;
									if (size % divide != 0)
									{
										Console.WriteLine("Error calculating array size for {0} at {1}, size {2} divided by {3}, assuming {4}", v2.ObjectType, (mdataarraypointer).ToString("X"), size, divide, size / divide);
									}
									int count = size / divide;
									//Console.WriteLine("{0} at {1}, next item: {2}, size {3}, count {4}", v2.ObjectType, mdataarraypointer.ToString("X"), nextitem.ToString("X"), size.ToString(), count.ToString());
									NJS_MOTION motion;
									if (v2.ObjectName.Substring(0, 8) == "mdata_al")
									{
										//Console.WriteLine("ROT");
										motion = new NJS_MOTION(data, entry.Key, imageBase, count, labellist, true);
									}
									else
									{
										motion = new NJS_MOTION(data, entry.Key, imageBase, count, labellist, false);
									}
									motion.Save(fileOutputPath);
									motionslist.Add(motion);
									ExportLabels(motion, dir + "\\labels", labelindex);
									itemparamlist.Add(motion.Name, new ItemParams { BoolParam = motion.ShortRot, IntParam = motion.ModelParts });
									//Console.WriteLine("Added motion {0}", motion.Name);
								}
							}
							catch (Exception ex)
							{
								Console.WriteLine("Split failed: {0}", ex.ToString());
							}
						}
					}
					//Scan for actions
					foreach (KeyValuePair<int, ItemDescriptor> entry in addresslist)
					{
						ItemDescriptor v = entry.Value;
						if (v.ObjectType == "NJS_ACTION")
						{
							if (noanims) continue;
							fileOutputPath = dir + "\\actions\\" + v.ObjectName;
							Console.WriteLine("Splitting {0} {1} at {2}", v.ObjectType, v.ObjectName, entry.Key.ToString("X"));
							try
							{
								NJS_ACTION ani = new NJS_ACTION(data, int.Parse(entry.Key.ToString("X"), NumberStyles.AllowHexSpecifier), imageBase, modelfmt, labellist, new Dictionary<int, Attach>());
								foreach (NJS_MOTION item in motionslist)
								{
									if (ani.Animation.Name == item.Name)
									{
										string aniName = ani.Name;
										ani = new NJS_ACTION(ani.Model, item);
										ani.Name = aniName;
										Console.WriteLine("Reusing motion {0} for action {1}", item.Name, ani.Name);
										deleteditems.Add(ani.Animation.Name);
										File.Delete(dir + "\\motions\\" + ani.Animation.Name + ".saanim");
									}
								}
								if (ani.Animation.ModelParts == 0)
								{
									Console.WriteLine("Animation of action {0} has no model parts, skipping", ani.Name);
									continue;
								}
								else
								{
									if (!actionlist.ContainsKey(ani.Model.Name))
									{
										List<string> actions = new List<string>();
										if (!skiplabels) actions.Add(ani.Name);
										else actions.Add(ani.Name.Substring(7, ani.Name.Length - 7));
										actionlist.Add(ani.Model.Name, actions);
										Console.WriteLine("New animation list for model {0} starting with {1}", ani.Model.Name, ani.Name);
									}
									else
									{
										foreach (KeyValuePair<string, List<string>> item in actionlist)
										{
											if (item.Key == ani.Model.Name)
											{
												if (!item.Value.Contains(ani.Animation.Name))
												{
													if (!skiplabels) item.Value.Add(ani.Name);
													else item.Value.Add(ani.Name.Substring(10, ani.Name.Length - 10));
													Console.WriteLine("Added animation for model {0}:{1}", ani.Model.Name, ani.Name);
												}
											}
										}
									}
									ani.Animation.Save(fileOutputPath + ".saanim");
									ExportLabels(ani, dir + "\\labels", labelindex);
									itemparamlist.Add(ani.Name, new ItemParams { StringParam = ani.Model.Name });
								}
							}
							catch (Exception ex)
							{
								Console.WriteLine("Split failed: {0}", ex.ToString());
							}
						}
					}
					//Scan for models and levels
					foreach (var entry in addresslist)
					{
						ItemDescriptor v = entry.Value;
						switch (v.ObjectType)
						{
							case "NJS_GC_OBJECT":
							case "gcobj":
								model_extension = ".sa2bmdl";
								fileOutputPath = dir + "\\gcmodels\\" + v.ObjectName;
								Console.WriteLine("Splitting {0} {1} at {2}", v.ObjectType, v.ObjectName, entry.Key.ToString("X"));
								try
								{
									NJS_OBJECT mdl = new NJS_OBJECT(data, int.Parse(entry.Key.ToString("X"), NumberStyles.AllowHexSpecifier), imageBase, ModelFormat.GC, labellist, new Dictionary<int, Attach>());
									List<string> mdlanis = new List<string>();
									if (actionlist.ContainsKey(mdl.Name))
									{
										foreach (KeyValuePair<string, List<string>> item in actionlist)
										{
											if (item.Key == mdl.Name)
											{
												foreach (string animname in item.Value)
												{
													mdlanis.Add("../actions/" + animname + ".saanim");
													Console.WriteLine("Adding animation {0} for model {1}", animname, mdl.Name);
												}
											}
										}
									}
									ModelFile.CreateFile(fileOutputPath + model_extension, mdl, mdlanis.ToArray(), null, null, null, ModelFormat.GC);
									ExportLabels(mdl, dir + "\\labels", labelindex);
									if (mdl.Children.Count > 0)
									{
										foreach (NJS_OBJECT child in mdl.Children)
										{
											if (!skiplabels)
											{
												File.Delete(dir + "\\gcmodels\\" + child.Name + model_extension);
												deleteditems.Add(child.Name);
											}
											else
											{
												if (File.Exists((dir + "\\gcmodels\\" + child.Name.Substring(7, child.Name.Length - 7) + model_extension)))
												{
													File.Delete(dir + "\\gcmodels\\" + child.Name.Substring(7, child.Name.Length - 7) + model_extension);
													deleteditems.Add(child.Name.Substring(7, child.Name.Length - 7));
												}
												else
												{
													int childaddr = int.Parse(child.Name.Substring(7, child.Name.Length - 7), NumberStyles.AllowHexSpecifier);
													//Console.WriteLine("Deleting at address :{0}", childaddr.ToString("X8"));
													foreach (var item in addresslist)
													{
														if (item.Key == childaddr)
														{
															ItemDescriptor v2 = item.Value;
															//Console.WriteLine("Deleting file: {0}", dir + "\\gcmodels\\" + v2.ObjectName + model_extension);
															File.Delete(dir + "\\gcmodels\\" + v2.ObjectName + model_extension);
															deleteditems.Add(v2.ObjectName);
														}
													}
												}
											}
										}
									}
									if (mdl.Sibling != null)
									{
										if (!skiplabels)
										{
											File.Delete(dir + "\\gcmodels\\" + mdl.Sibling.Name + model_extension);
											deleteditems.Add(mdl.Sibling.Name);
										}
										else
										{
											if (File.Exists(dir + "\\gcmodels\\" + mdl.Sibling.Name.Substring(7, mdl.Sibling.Name.Length - 7) + model_extension))
											{
												File.Delete(dir + "\\gcmodels\\" + mdl.Sibling.Name.Substring(7, mdl.Sibling.Name.Length - 7) + model_extension);
												deleteditems.Add(mdl.Sibling.Name.Substring(7, mdl.Sibling.Name.Length - 7));
											}
											else
											{
												foreach (var item in addresslist)
												{
													if (item.Key == int.Parse(mdl.Sibling.Name.Substring(7, mdl.Sibling.Name.Length - 7), NumberStyles.AllowHexSpecifier))
													{
														ItemDescriptor v2 = item.Value;
														//Console.WriteLine("Deleting file: {0}", dir + "\\gcmodels\\" + v2.ObjectName + model_extension);
														File.Delete(dir + "\\gcmodels\\" + v2.ObjectName + model_extension);
														deleteditems.Add(v2.ObjectName);
													}
												}
											}
										}
									}
									if (mdlanis.Count > 0)
									{
										string allmodels = string.Join(",", mdlanis);
										itemparamlist.Add(mdl.Name, new ItemParams { StringParam = allmodels });
									}
								}
								catch (Exception ex)
								{
									Console.WriteLine("Split failed: {0}", ex.ToString());
								}
								break;
							case "NJS_CNK_OBJECT":
							case "cnkobj":
								model_extension = ".sa2mdl";
								fileOutputPath = dir + "\\chunkmodels\\" + v.ObjectName;
								Console.WriteLine("Splitting {0} {1} at {2}", v.ObjectType, v.ObjectName, entry.Key.ToString("X"));
								try
								{
									NJS_OBJECT mdl = new NJS_OBJECT(data, int.Parse(entry.Key.ToString("X"), NumberStyles.AllowHexSpecifier), imageBase, ModelFormat.Chunk, labellist, new Dictionary<int, Attach>());
									List<string> mdlanis = new List<string>();
									if (actionlist.ContainsKey(mdl.Name))
									{
										foreach (KeyValuePair<string, List<string>> item in actionlist)
										{
											if (item.Key == mdl.Name)
											{
												foreach (string animname in item.Value)
												{
													mdlanis.Add("../actions/" + animname + ".saanim");
													Console.WriteLine("Adding animation {0} for model {1}", animname, mdl.Name);
												}
											}
										}
									}
									ModelFile.CreateFile(fileOutputPath + model_extension, mdl, mdlanis.ToArray(), null, null, null, ModelFormat.Chunk);
									ExportLabels(mdl, dir + "\\labels", labelindex);
									if (mdl.Children.Count > 0)
									{
										foreach (NJS_OBJECT child in mdl.Children)
										{
											if (!skiplabels)
											{
												File.Delete(dir + "\\chunkmodels\\" + child.Name + model_extension);
												deleteditems.Add(child.Name);
											}
											else
											{
												if (File.Exists((dir + "\\chunkmodels\\" + child.Name.Substring(7, child.Name.Length - 7) + model_extension)))
												{
													File.Delete(dir + "\\chunkmodels\\" + child.Name.Substring(7, child.Name.Length - 7) + model_extension);
													deleteditems.Add(child.Name.Substring(7, child.Name.Length - 7));
												}
												else
												{
													int childaddr = int.Parse(child.Name.Substring(7, child.Name.Length - 7), NumberStyles.AllowHexSpecifier);
													//Console.WriteLine("Deleting at address :{0}", childaddr.ToString("X8"));
													foreach (var item in addresslist)
													{
														if (item.Key == childaddr)
														{
															ItemDescriptor v2 = item.Value;
															//Console.WriteLine("Deleting file: {0}", dir + "\\chunkmodels\\" + v2.ObjectName + model_extension);
															File.Delete(dir + "\\chunkmodels\\" + v2.ObjectName + model_extension);
															deleteditems.Add(v2.ObjectName);
														}
													}
												}
											}
										}
									}
									if (mdl.Sibling != null)
									{
										if (!skiplabels)
										{
											File.Delete(dir + "\\chunkmodels\\" + mdl.Sibling.Name + model_extension);
											deleteditems.Add(mdl.Sibling.Name);
										}
										else
										{
											if (File.Exists(dir + "\\chunkmodels\\" + mdl.Sibling.Name.Substring(7, mdl.Sibling.Name.Length - 7) + model_extension))
											{
												File.Delete(dir + "\\chunkmodels\\" + mdl.Sibling.Name.Substring(7, mdl.Sibling.Name.Length - 7) + model_extension);
												deleteditems.Add(mdl.Sibling.Name.Substring(7, mdl.Sibling.Name.Length - 7));
											}
											else
											{
												foreach (var item in addresslist)
												{
													if (item.Key == int.Parse(mdl.Sibling.Name.Substring(7, mdl.Sibling.Name.Length - 7), NumberStyles.AllowHexSpecifier))
													{
														ItemDescriptor v2 = item.Value;
														//Console.WriteLine("Deleting file: {0}", dir + "\\chunkmodels\\" + v2.ObjectName + model_extension);
														File.Delete(dir + "\\chunkmodels\\" + v2.ObjectName + model_extension);
														deleteditems.Add(v2.ObjectName);
													}
												}
											}
										}
									}
									if (mdlanis.Count > 0)
									{
										string allmodels = string.Join(",", mdlanis);
										itemparamlist.Add(mdl.Name, new ItemParams { StringParam = allmodels });
									}
								}
								catch (Exception ex)
								{
									Console.WriteLine("Split failed: {0}", ex.ToString());
								}
								break;
							case "NJS_OBJECT":
							case "obj":
								model_extension = ".sa1mdl";
								fileOutputPath = dir + "\\basicmodels\\" + v.ObjectName;
								Console.WriteLine("Splitting {0} {1} at {2}", v.ObjectType, v.ObjectName, entry.Key.ToString("X"));
								try
								{
									NJS_OBJECT mdl = new NJS_OBJECT(data, int.Parse(entry.Key.ToString("X"), NumberStyles.AllowHexSpecifier), imageBase, modelfmt, labellist, new Dictionary<int, Attach>());
									List<string> mdlanis = new List<string>();
									if (actionlist.ContainsKey(mdl.Name))
									{
										foreach (KeyValuePair<string, List<string>> item in actionlist)
										{
											if (item.Key == mdl.Name)
											{
												foreach (string animname in item.Value)
												{
													mdlanis.Add("../actions/" + animname + ".saanim");
													Console.WriteLine("Adding animation {0} for model {1}", animname, mdl.Name);
												}
											}
										}
									}
									ModelFile.CreateFile(fileOutputPath + model_extension, mdl, mdlanis.ToArray(), null, null, null, modelfmt);
									ExportLabels(mdl, dir + "\\labels", labelindex);
									if (mdl.Children.Count > 0)
									{
										foreach (NJS_OBJECT child in mdl.Children)
										{
											if (!skiplabels)
											{
												File.Delete(dir + "\\basicmodels\\" + child.Name + model_extension);
												deleteditems.Add(child.Name);
											}
											else
											{
												if (File.Exists((dir + "\\basicmodels\\" + child.Name.Substring(7, child.Name.Length - 7) + model_extension)))
												{
													File.Delete(dir + "\\basicmodels\\" + child.Name.Substring(7, child.Name.Length - 7) + model_extension);
													deleteditems.Add(child.Name.Substring(7, child.Name.Length - 7));
												}
												else
												{
													int childaddr = int.Parse(child.Name.Substring(7, child.Name.Length - 7), NumberStyles.AllowHexSpecifier);
													//Console.WriteLine("Deleting at address :{0}", childaddr.ToString("X8"));
													foreach (var item in addresslist)
													{
														if (item.Key == childaddr)
														{
															ItemDescriptor v2 = item.Value;
															//Console.WriteLine("Deleting file: {0}", dir + "\\basicmodels\\" + v2.ObjectName + model_extension);
															File.Delete(dir + "\\basicmodels\\" + v2.ObjectName + model_extension);
															deleteditems.Add(v2.ObjectName);
														}
													}
												}
											}
										}
									}
									if (mdl.Sibling != null)
									{
										if (!skiplabels)
										{
											File.Delete(dir + "\\basicmodels\\" + mdl.Sibling.Name + model_extension);
											deleteditems.Add(mdl.Sibling.Name);
										}
										else
										{
											if (File.Exists(dir + "\\basicmodels\\" + mdl.Sibling.Name.Substring(7, mdl.Sibling.Name.Length - 7) + model_extension))
											{
												File.Delete(dir + "\\basicmodels\\" + mdl.Sibling.Name.Substring(7, mdl.Sibling.Name.Length - 7) + model_extension);
												deleteditems.Add(mdl.Sibling.Name.Substring(7, mdl.Sibling.Name.Length - 7));
											}
											else
											{
												foreach (var item in addresslist)
												{
													if (item.Key == int.Parse(mdl.Sibling.Name.Substring(7, mdl.Sibling.Name.Length - 7), NumberStyles.AllowHexSpecifier))
													{
														ItemDescriptor v2 = item.Value;
														//Console.WriteLine("Deleting file: {0}", dir + "\\basicmodels\\" + v2.ObjectName + model_extension);
														File.Delete(dir + "\\basicmodels\\" + v2.ObjectName + model_extension);
														deleteditems.Add(v2.ObjectName);
													}
												}
											}
										}
									}
									if (mdlanis.Count > 0)
									{
										string allmodels = string.Join(",", mdlanis);
										itemparamlist.Add(mdl.Name, new ItemParams { StringParam = allmodels });
									}
								}
								catch (Exception ex)
								{
									Console.WriteLine("Split failed: {0}", ex.ToString());
								}
								break;
							case "LandTable":
							case "_OBJ_LANDTABLE":
								fileOutputPath = dir + "\\levels\\" + v.ObjectName;
								Console.WriteLine("Splitting {0} {1} at {2}", v.ObjectType, v.ObjectName, entry.Key.ToString("X"));
								try
								{
									LandTable land = new LandTable(data, int.Parse(entry.Key.ToString("X"), NumberStyles.AllowHexSpecifier), imageBase, landfmt, labellist);
									land.SaveToFile(fileOutputPath + landtable_extension, landfmt);
									ExportLabels(land, dir + "\\labels", labelindex);
									landlist.Add(land);
								}
								catch (Exception ex)
								{
									Console.WriteLine("Split failed: {0}", ex.ToString());
								}
								break;
						}
					}
					//Clean up stuff that is included in landtables
					foreach (LandTable land in landlist)
					{
						if (land.COL.Count > 0)
						{
							foreach (COL col in land.COL)
							{
								if (!skiplabels)
								{
									File.Delete(dir + "\\basicmodels\\" + col.Model.Name + model_extension);
									deleteditems.Add(col.Model.Name);
								}
								else
								{
									//Console.WriteLine("Deleting file {0}", dir + "\\" + col.Model.Name + model_extension);
									File.Delete(dir + "\\basicmodels\\" + col.Model.Name.Substring(7, col.Model.Name.Length - 7) + model_extension);
									deleteditems.Add(col.Model.Name.Substring(7, col.Model.Name.Length - 7));
								}
							}
						}
						if (land.Anim.Count > 0)
						{
							foreach (GeoAnimData anim in land.Anim)
							{
								if (!skiplabels)
								{
									File.Delete(dir + "\\basicmodels\\" + anim.Model.Name + model_extension);
									File.Delete(dir + "\\motions\\" + anim.Animation.Name + ".saanim");
									deleteditems.Add(anim.Model.Name);
									deleteditems.Add(anim.Animation.Name);
								}
								else
								{
									File.Delete(dir + "\\basicmodels\\" + anim.Model.Name.Substring(7, anim.Model.Name.Length - 7) + model_extension);
									File.Delete(dir + "\\motions\\" + anim.Animation.Name.Substring(10, anim.Animation.Name.Length - 10) + ".saanim");
									deleteditems.Add(anim.Model.Name.Substring(7, anim.Model.Name.Length - 7));
									deleteditems.Add(anim.Animation.Name.Substring(10, anim.Animation.Name.Length - 10));
								}
								//Console.WriteLine("Deleting file {0}", dir + "\\" + anim.Model.Name + model_extension);
							}
						}
					}
					//Export labels
					Console.WriteLine("Creating labels: {0}", System.IO.Path.Combine(dir, Path.GetFileNameWithoutExtension(filename) + "_labels.txt"));
					IniSerializer.Serialize(labellist, System.IO.Path.Combine(dir, Path.GetFileNameWithoutExtension(filename) + "_labels.txt"));
					/*
					//List deleted items
					Console.WriteLine("Deleted items: {0}", System.IO.Path.Combine(dir, Path.GetFileNameWithoutExtension(filename) + "_deleted.txt"));
					IniSerializer.Serialize(deleteditems, System.IO.Path.Combine(dir, Path.GetFileNameWithoutExtension(filename) + "_deleted.txt"));
					//Serialize the descriptors
					Console.WriteLine("Debug output items: {0}", System.IO.Path.Combine(dir, Path.GetFileNameWithoutExtension(filename) + "_debug.txt"));
					IniSerializer.Serialize(addresslist, System.IO.Path.Combine(dir, Path.GetFileNameWithoutExtension(filename) + "_debug.txt"));
					*/
					//Create split INI
					IniSerializer.Serialize(labelindex, System.IO.Path.Combine(dir, "labels", "index.txt"));
					SplitListToINI(addresslist, dir + "\\" + Path.GetFileNameWithoutExtension(filename) + ".ini", game, imageBase, bigendian, reverse, address, deleteditems, itemparamlist);
					break;
				case "landtable":
					new LandTable(datafile, address, imageBase, landfmt).SaveToFile(fileOutputPath + landtable_extension, landfmt);
					break;
				case "model":
					{
						NJS_OBJECT mdl = new NJS_OBJECT(datafile, address, imageBase, modelfmt, new Dictionary<int, Attach>());
						ModelFile.CreateFile(fileOutputPath + model_extension, mdl, null, null, null, null, modelfmt);
					}
					break;
				case "basicmodel":
					{
						NJS_OBJECT mdl = new NJS_OBJECT(datafile, address, imageBase, ModelFormat.Basic, new Dictionary<int, Attach>());
						ModelFile.CreateFile(fileOutputPath + ".sa1mdl", mdl, null, null, null, null, ModelFormat.Basic);
					}
					break;
				case "basicdxmodel":
					{
						NJS_OBJECT mdl = new NJS_OBJECT(datafile, address, imageBase, ModelFormat.BasicDX, new Dictionary<int, Attach>());
						ModelFile.CreateFile(fileOutputPath + ".sa1mdl", mdl, null, null, null, null, ModelFormat.BasicDX);
					}
					break;
				case "chunkmodel":
					{
						NJS_OBJECT mdl = new NJS_OBJECT(datafile, address, imageBase, ModelFormat.Chunk, new Dictionary<int, Attach>());
						ModelFile.CreateFile(fileOutputPath + ".sa2mdl", mdl, null, null, null, null, ModelFormat.Chunk);
					}
					break;
				case "gcmodel":
					{
						NJS_OBJECT mdl = new NJS_OBJECT(datafile, address, imageBase, ModelFormat.GC, new Dictionary<int, Attach>());
						ModelFile.CreateFile(fileOutputPath + ".sa2bmdl", mdl, null, null, null, null, ModelFormat.GC);
					}
					break;
				case "action":
					{
						NJS_ACTION ani = new NJS_ACTION(datafile, address, imageBase, modelfmt, new Dictionary<int, Attach>());
						ani.Animation.Save(fileOutputPath + ".saanim");
						string[] mdlanis = new string[0];
						NJS_OBJECT mdl = ani.Model;
						mdlanis = (fileOutputPath + ".saanim").Split(',');
						ModelFile.CreateFile(fileOutputPath + "_model" + model_extension, mdl, mdlanis, null, null, null, modelfmt);
					}
					break;
				case "animation":
					{
						NJS_OBJECT mdl = new NJS_OBJECT(datafile, intparam, imageBase, modelfmt, new Dictionary<int, Attach>());
						new NJS_MOTION(datafile, address, imageBase, mdl.CountAnimated(), shortrot: boolparam).Save(fileOutputPath + ".saanim");
						string[] mdlanis = new string[0];
						mdlanis = (fileOutputPath + ".saanim").Split(',');
						ModelFile.CreateFile(fileOutputPath + "_model" + model_extension, mdl, mdlanis, null, null, null, modelfmt);
					}
					break;
				case "animmdl":
					{
						ModelFile mdlFile = new ModelFile(stringparam);
						int nodeCount = mdlFile.Model.CountAnimated();
						if (bigendian == true)
						{
							ByteConverter.BigEndian = true;
						}
						new NJS_MOTION(datafile, address, imageBase, nodeCount, shortrot: boolparam).Save(fileOutputPath + ".saanim");
						string[] mdlanis = new string[0];
						mdlanis = (fileOutputPath + ".saanim").Split(',');
					}
					break;
				case "motion":
					{
						new NJS_MOTION(datafile, address, imageBase, intparam, shortrot: boolparam).Save(fileOutputPath + ".saanim");
					}
					break;
				case "objlist":
					{
						ObjectListEntry[] objs = ObjectList.Load(datafile, address, imageBase, SA2);
						foreach (ObjectListEntry obj in objs)
						{
							if (!masterobjlist.ContainsKey(obj.CodeString))
								masterobjlist.Add(obj.CodeString, new MasterObjectListEntry(obj));
							if (!objnamecounts.ContainsKey(obj.CodeString))
								objnamecounts.Add(obj.CodeString, new Dictionary<string, int>() { { obj.Name, 1 } });
							else if (!objnamecounts[obj.CodeString].ContainsKey(obj.Name))
								objnamecounts[obj.CodeString].Add(obj.Name, 1);
							else
								objnamecounts[obj.CodeString][obj.Name]++;
						}
						objs.Save(fileOutputPath + ".ini");
					}
					break;
				case "startpos":
					if (SA2)
						SA2StartPosList.Load(datafile, address).Save(fileOutputPath + ".ini");
					else
						SA1StartPosList.Load(datafile, address).Save(fileOutputPath + ".ini");
					break;
				case "texlist":
					TextureList.Load(datafile, address, imageBase).Save(fileOutputPath + ".ini");
					break;
				case "texnamearray":
					TexnameArray texnames = new TexnameArray(datafile, address, imageBase);
					StreamWriter sw = File.CreateText(fileOutputPath + "_texnames.txt");
					for (int u = 0; u < texnames.GetNumTextures(); u++)
					{
						sw.WriteLine(texnames.TextureNames[u] + ".pvr");
					}
					sw.Flush();
					sw.Close();
					break;
				case "leveltexlist":
					new LevelTextureList(datafile, address, imageBase).Save(fileOutputPath + ".ini");
					break;
				case "triallevellist":
					TrialLevelList.Save(TrialLevelList.Load(datafile, address, imageBase), fileOutputPath + ".ini");
					break;
				case "bosslevellist":
					BossLevelList.Save(BossLevelList.Load(datafile, address), fileOutputPath + ".ini");
					break;
				case "fieldstartpos":
					FieldStartPosList.Load(datafile, address).Save(fileOutputPath + ".ini");
					break;
				case "soundtestlist":
					SoundTestList.Load(datafile, address, imageBase).Save(fileOutputPath + ".ini");
					break;
				case "musiclist":
					{
						MusicList.Load(datafile, address, imageBase, intparam).Save(fileOutputPath + ".ini");
					}
					break;
				case "soundlist":
					SoundList.Load(datafile, address, imageBase).Save(fileOutputPath + ".ini");
					break;
				case "stringarray":
					{
						Languages lang = Languages.Japanese;
						if (stringparam != "")
							lang = (Languages)Enum.Parse(typeof(Languages), stringparam, true);
						StringArray.Load(datafile, address, imageBase, intparam, lang).Save(fileOutputPath + ".txt");
					}
					break;
				case "nextlevellist":
					NextLevelList.Load(datafile, address).Save(fileOutputPath + ".ini");
					break;
				case "cutscenetext":
					{
						new CutsceneText(datafile, address, imageBase, intparam).Save(fileOutputPath + ".txt", out string[] hashes);
					}
					break;
				case "recapscreen":
					{
						RecapScreenList.Load(datafile, address, imageBase, intparam).Save(fileOutputPath + ".txt", out string[][] hashes);
					}
					break;
				case "npctext":
					{
						NPCTextList.Load(datafile, address, imageBase, intparam).Save(fileOutputPath + ".txt", out string[][] hashes);
					}
					break;
				case "levelclearflags":
					LevelClearFlagList.Save(LevelClearFlagList.Load(datafile, address), fileOutputPath + ".ini");
					break;
				case "deathzone":
					{
						List<DeathZoneFlags> flags = new List<DeathZoneFlags>();
						string path = Path.GetDirectoryName(fileOutputPath);
						List<string> hashes = new List<string>();
						int num = 0;
						while (ByteConverter.ToUInt32(datafile, address + 4) != 0)
						{
							flags.Add(new DeathZoneFlags(datafile, address));
							string file = Path.Combine(path, num++.ToString(NumberFormatInfo.InvariantInfo) + (modelfmt == ModelFormat.Chunk ? ".sa2mdl" : ".sa1mdl"));
							ModelFile.CreateFile(file, new NJS_OBJECT(datafile, datafile.GetPointer(address + 4, imageBase), imageBase, modelfmt, new Dictionary<int, Attach>()), null, null, null, null, modelfmt);
							address += 8;
						}
						flags.ToArray().Save(fileOutputPath + ".ini");
					}
					break;
				case "skyboxscale":
					{
						SkyboxScaleList.Load(datafile, address, imageBase, intparam).Save(fileOutputPath + ".ini");
					}
					break;
				case "stageselectlist":
					{
						StageSelectLevelList.Load(datafile, address, intparam).Save(fileOutputPath + ".ini");
					}
					break;
				case "levelrankscores":
					LevelRankScoresList.Load(datafile, address).Save(fileOutputPath + ".ini");
					break;
				case "levelranktimes":
					LevelRankTimesList.Load(datafile, address).Save(fileOutputPath + ".ini");
					break;
				case "endpos":
					SA2EndPosList.Load(datafile, address).Save(fileOutputPath + ".ini");
					break;
				case "animationlist":
					{
						SA2AnimationInfoList.Load(datafile, address, intparam).Save(fileOutputPath + ".ini");
					}
					break;
				case "sa1actionlist":
					{
						SA1ActionInfoList.Load(datafile, address, imageBase, intparam).Save(fileOutputPath + ".ini");
					}
					break;
				case "enemyanimationlist":
					{
						SA2EnemyAnimInfoList.Load(datafile, address, imageBase, intparam).Save(fileOutputPath + ".ini");
					}
					break;
				case "levelpathlist":
					{
						ushort lvlnum = (ushort)ByteConverter.ToUInt32(datafile, address);
						while (lvlnum != 0xFFFF)
						{
							int ptr = ByteConverter.ToInt32(datafile, address + 4);
							if (ptr != 0)
							{
								ptr = (int)((uint)ptr - imageBase);
								SA1LevelAct level = new SA1LevelAct(lvlnum);
								string lvldir = Path.Combine(fileOutputPath, level.ToString());
								PathList.Load(datafile, ptr, imageBase).Save(lvldir, out string[] lvlhashes);
							}
							address += 8;
							lvlnum = (ushort)ByteConverter.ToUInt32(datafile, address);
						}
					}
					break;
				case "pathlist":
					{
						PathList.Load(datafile, address, imageBase).Save(fileOutputPath, out string[] hashes);
					}
					break;
				case "stagelightdatalist":
					SA1StageLightDataList.Load(datafile, address).Save(fileOutputPath);
					break;
				case "weldlist":
					WeldList.Load(datafile, address, imageBase).Save(fileOutputPath);
					break;
				case "bmitemattrlist":
					BlackMarketItemAttributesList.Load(datafile, address, imageBase).Save(fileOutputPath);
					break;
				case "creditstextlist":
					CreditsTextList.Load(datafile, address, imageBase).Save(fileOutputPath);
					break;
				case "animindexlist":
					{
						Directory.CreateDirectory(fileOutputPath);
						List<string> hashes = new List<string>();
						int i = ByteConverter.ToInt16(datafile, address);
						while (i != -1)
						{
							new NJS_MOTION(datafile, datafile.GetPointer(address + 4, imageBase), imageBase, ByteConverter.ToInt16(datafile, address + 2))
								.Save(fileOutputPath + "/" + i.ToString(NumberFormatInfo.InvariantInfo) + ".saanim");
							hashes.Add(i.ToString(NumberFormatInfo.InvariantInfo) + ":" + HelperFunctions.FileHash(fileOutputPath + "/" + i.ToString(NumberFormatInfo.InvariantInfo) + ".saanim"));
							address += 8;
							i = ByteConverter.ToInt16(datafile, address);
						}
					}
					break;
				case "storysequence":
					SA2StoryList.Load(datafile, address).Save(fileOutputPath);
					break;
				case "masterstringlist":
					{
						for (int l = 0; l < 5; l++)
						{
							Languages lng = (Languages)l;
							System.Text.Encoding enc = HelperFunctions.GetEncoding(game, lng);
							string ld = Path.Combine(fileOutputPath, lng.ToString());
							Directory.CreateDirectory(ld);
							int ptr = datafile.GetPointer(address, imageBase);
							for (int i = 0; i < intparam; i++)
							{
								int ptr2 = datafile.GetPointer(ptr, imageBase);
								if (ptr2 != 0)
								{
									string fn = Path.Combine(ld, $"{i}.txt");
									File.WriteAllText(fn, datafile.GetCString(ptr2, enc).Replace("\n", "\r\n"));
								}
								ptr += 4;
							}
							address += 4;
						}
					}
					break;
				case "binary":
					{
						byte[] bin = new byte[intparam];
						Array.Copy(datafile, address, bin, 0, bin.Length);
						File.WriteAllBytes(fileOutputPath + ".bin", bin);
						Console.WriteLine("Length: {0} (0x{1}) bytes", intparam.ToString(), intparam.ToString("X"));
					}
					break;
				default:
					{
						Console.WriteLine("Error parsing data type. Run the program without arguments for a list of usable data types.");
						Console.WriteLine("Press ENTER to exit.");
						Console.ReadLine();
						return;
					}
			}
		}
		catch (Exception ex)
		{
			Console.WriteLine("Split operation failed: " + ex.ToString());
		}
	}
}

namespace USplit
{
	class Program
	{
		static void Main(string[] args)
		{
			Game game;
			string filename;
			uint key;
			int address;
			string type;
			int intparam = 0;
			string stringparam = "";
			string name = "";
			bool boolparam = false;
			bool bigendian = false;
			bool reverse = false;
			if (args.Length == 0)
			{
				Console.WriteLine("USplit is a tool that lets you extract any data supported by SA Tools from any binary file.");
				Console.WriteLine("Usage: usplit <GAME> <FILENAME> <KEY> <TYPE> <ADDRESS> <PARAMETER1> <PARAMETER2> [-name <NAME>]\n");
				Console.WriteLine("Argument description:");
				Console.WriteLine("<GAME>: SA1, SADX, SA2, SA2B. Add '_b' (e.g. SADX_b) to switch to Big Endian, use SADX_g to scan the Gamecube version of SADX.");
				Console.WriteLine("<FILENAME>: The name of the binary file, e.g. sonic.exe.");
				Console.WriteLine("<KEY>: Binary key, e.g. 400000 for sonic.exe or C900000 for SA1 STG file.");
				Console.WriteLine("<TYPE>: One of the following:\n" +
					"| action | basicdxmodel | basicmodel | chunkmodel | deathzone | gcmodel | landtable | model |\n" +
					"| endpos | fieldstartpos | levelclearflags | levelrankscores | levelranktimes | startpos | storysequence |\n" +
					"| texnamearray | animindexlist | bmitemattrlist | creditstextlist | leveltexlist | objlist | pathlist |\n" +
					"| soundlist | soundtestlist | stagelightdatalist | texlist | weldlist | bosslevellist | levelpathlist |\n" +
					"| nextlevellist | triallevellist |\n" +
					"| animationlist <count> | cutscenetext <count> | masterstringlist <count> | musiclist <count> | npctext <count> |\n" +
					"| recapscreen <count> | skyboxscale <count> | stageselectlist <count> | sa1actionlist <count> | enemyanimationlist <count> |\n" +
					"| stringarray <count> [language] | list <offset> <filename> [-skiplabels] [-noanims] | binary <length> [hex] |\n" +
					"| animation <NJS_OBJECT address> [-shortrot] | animmdl <*mdl file> [-shortrot] | motion <nodecount> [-shortrot]");
				Console.WriteLine("<ADDRESS>: The location of data in the file.");
				Console.WriteLine("<PARAMETER1>: length, count, secondary address etc. depending on data type");
				Console.WriteLine("<PARAMETER2>: 'hex' for binary to read length as hexadecimal, 'shortrot' for animation to read rotation as short");
				Console.WriteLine("<NAME>: Output file name (optional)");
				Console.WriteLine("Press ENTER to exit");
				Console.ReadLine();
				return;
			}
			else
			{
				//Args list: game, filename, key, type, address, [address2/count], [language], [name]
				switch (args[0].ToLowerInvariant())
				{
					case "-labeltotype":
						if (args.Length != 3)
						{
							Console.WriteLine("Incorrect arguments for 'label to type' mode. Correct arguments are:\nusplit -labeltotype <list> <labellist>");
							Console.ReadLine();
							return;
						}
						Dictionary<int, ItemDescriptor> addresslist_x = new Dictionary<int, ItemDescriptor>(); //Main list of addresses, types and labels
						ParseDictionary(addresslist_x, null, args[1], false);
						Dictionary<int, string> matchresultlistx = IniSerializer.Deserialize<Dictionary<int, string>>(args[2]); //Final list of 2004PC model names
						foreach (var item in addresslist_x)
						{
							ItemDescriptor desc = item.Value;
							foreach (var match in matchresultlistx)
							{
								if (match.Value == desc.ObjectName)
								{
									Console.WriteLine("{0}, {1}, {2}", (0x400000 + match.Key).ToString("X8"), desc.ObjectType, desc.ObjectName);
								}
							}
						}
						return;
					case "-match":
						if (args.Length != 3)
						{
							Console.WriteLine("Incorrect arguments for 'match' mode. Correct arguments are:\nusplit -match <structslist> <matchlist>");
							Console.ReadLine();
							return;
						}
						string dir = Environment.CurrentDirectory;
						Dictionary<int, string> matchresultlist = new Dictionary<int, string>(); //Final list of 2004PC model names
						Dictionary<int, ItemDescriptor> addresslist_m = new Dictionary<int, ItemDescriptor>(); //Main list of addresses, types and labels
						ParseDictionary(addresslist_m, null, args[1], false);
						using (TextReader addr_matchlist = File.OpenText(args[2]))
						{
							string line = addr_matchlist.ReadLine();
							while (line != null)
							{
								string[] split = line.Split(',');
								int x360addr = int.Parse(split[1], NumberStyles.AllowHexSpecifier);
								int dx2004addr = int.Parse(split[0], NumberStyles.AllowHexSpecifier);
								if (matchresultlist.ContainsKey(dx2004addr))
								{
									Console.WriteLine("Address {0} already contains label {1}", dx2004addr.ToString("X"), matchresultlist[dx2004addr]);
								}
								else if (addresslist_m.ContainsKey(x360addr))
								{
									matchresultlist.Add(dx2004addr, addresslist_m[x360addr].ObjectName);
									Console.WriteLine("{0} is {1}", dx2004addr.ToString("X"), addresslist_m[x360addr].ObjectName);
								}
								line = addr_matchlist.ReadLine();
							}
						}
						IniSerializer.Serialize(matchresultlist, System.IO.Path.Combine(dir, Path.GetFileNameWithoutExtension(args[1]) + "_match.txt"));
						Console.WriteLine("Matching complete. Labels are saved in " + System.IO.Path.Combine(dir, Path.GetFileNameWithoutExtension(args[1]) + "_match.txt"));
						return;
					case "sa1":
						game = Game.SA1;
						break;
					case "sa1_b":
						game = Game.SA1;
						bigendian = true;
						break;
					case "sadx":
						game = Game.SADX;
						break;
					case "sadx_b":
						game = Game.SADX;
						bigendian = true;
						break;
					case "sadx_g":
						game = Game.SA1;
						bigendian = true;
						reverse = true;
						break;
					case "sa2":
						game = Game.SA2;
						break;
					case "sa2_b":
						game = Game.SA2;
						bigendian = true;
						break;
					case "sa2b":
						game = Game.SA2B;
						break;
					case "sa2b_b":
						game = Game.SA2B;
						bigendian = true;
						break;
					default:
						Console.WriteLine("Error parsing game type.\nCorrect game types are: SA1, SADX, SA2, SA2B.");
						Console.WriteLine("Press ENTER to exit.");
						Console.ReadLine();
						return;
				}
				filename = args[1];
				key = uint.Parse(args[2], NumberStyles.AllowHexSpecifier);
				type = args[3];
				address = int.Parse(args[4], NumberStyles.AllowHexSpecifier);
				if (args.Length > 5 && args[5] != "-name")
				{
					if (type != "list") intparam = int.Parse(args[5]);
					else stringparam = args[5];
				}
				if (args.Length > 6 && args[6] != "-name") stringparam = args[6];
				for (int a = 0; a < args.Length; a++)
				{
					switch (args[a])
					{
						case "-shortrot":
							boolparam = true;
							break;
						case "-name":
							name = args[a];
							break;
						case "-hex":
							intparam = int.Parse(args[a - 1], NumberStyles.AllowHexSpecifier);
							break;
					}
				}
				SplitSingle(game, filename, key, type, address, boolparam, intparam, stringparam, name, bigendian, reverse);
			}
		}
	}
}
