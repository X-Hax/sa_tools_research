using SAModel;
using SplitTools;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;

// Methods to retrieve and export labels
namespace LabelTool
{
    partial class Program
    {
        // Opens two files and exports labels from the second file matching addresses in the first file using a label database in the "labels" folder
        // Labels: https://dcmods.unreliable.network/owncloud/data/PiKeyAr/files/SA1%20research/x360_labeldb.7z
        static void TransferLabels(string path_nolabel, string path_label, TextWriter writer_split, TextWriter writer_ida, Dictionary<string, int> labelindex)
        {
            switch (Path.GetExtension(path_nolabel).ToLowerInvariant())
            {
                case ".sa1mdl":
                case ".sa2mdl":
                    NJS_OBJECT obj_nolabel = new ModelFile(path_nolabel).Model;
                    NJS_OBJECT obj_label = new ModelFile(path_label).Model;
                    ExportAddr(obj_nolabel, "labels", writer_split, writer_ida, obj_label.Name, labelindex);
                    break;
                case ".saanim":
                    NJS_MOTION mot_nolabel = NJS_MOTION.Load(path_nolabel);
                    NJS_MOTION mot_label = NJS_MOTION.Load(path_label);
                    ExportAddr(mot_nolabel, "labels", writer_split, writer_ida, mot_label.Name, labelindex);
                    break;
                case ".sa1lvl":
                case ".sa2lvl":
                    LandTable lnd_nolabel = LandTable.LoadFromFile(path_nolabel);
                    LandTable lnd_label = LandTable.LoadFromFile(path_label);
                    ExportAddr(lnd_nolabel, "labels", writer_split, writer_ida, lnd_label.Name, labelindex);
                    break;
            }
        }

        static int GetAddressFromLabel(string label)
        {
            Console.WriteLine(label);
            if (label == null || label.Length < 11) //Smallest possible autogenerated name like "uv_..."
                return 0;
            int addr;
            bool succ = int.TryParse(label.Substring(label.Length - 8, 8), NumberStyles.AllowHexSpecifier, null, out addr);
            if (succ == false)
                Console.WriteLine("Name {0} couldn't be parsed", label);
            return addr;
        }

        static void AddAddress(string type, string name, string label, TextWriter writer_split, TextWriter writer_ida)
        {
            int addr;
            if (label == null) return;
            addr = GetAddressFromLabel(name);
            if (addr != 0)
            {
                writer_split.WriteLine("{1}={0}", label, addr);
                writer_ida.WriteLine("{0},{1},{2}", type, label, (addr + 0x400000).ToString("X"));
                Console.WriteLine("{0} at {1} is {2}", type, addr.ToString("X"), label);
            }
        }

        static void ExportAddr(NJS_OBJECT mdl, string path, TextWriter writer_split, TextWriter writer_ida, string label, Dictionary<string, int> labelindex)
        {
            AddAddress("NJS_OBJECT", mdl.Name, label, writer_split, writer_ida);
            if (!labelindex.ContainsKey(label))
            {
                Console.WriteLine("Label {0} not found", label);
                return;
            }
            bool succ = labelindex.TryGetValue(label, out int indx);
            if (!succ)
            {
                Console.WriteLine("Name {0} missing in the address list", label);
                return;
            }
            Label_OBJECT desc = IniSerializer.Deserialize<Label_OBJECT>(Path.Combine(path, indx.ToString() + ".txt"));
            if (mdl.Attach != null)
            {
                if (mdl.Attach is BasicAttach)
                {
                    AddAddress("NJS_MODEL_SADX", mdl.Attach.Name, desc.AtachName, writer_split, writer_ida);
                    BasicAttach attach = (BasicAttach)mdl.Attach;
                    if (attach.Vertex != null) AddAddress(attach.Vertex.Length.ToString() + ",NJS_VECTOR", attach.VertexName, desc.VertexName, writer_split, writer_ida);
                    if (attach.Normal != null) AddAddress(attach.Normal.Length.ToString() + ",NJS_VECTOR", attach.NormalName, desc.NormalName, writer_split, writer_ida);
                    if (attach.Material != null) AddAddress(attach.Material.Count.ToString() + ",NJS_MATERIAL", attach.MaterialName, desc.MaterialName, writer_split, writer_ida);
                    if (attach.Mesh != null && attach.Mesh.Count > 0)
                    {
                        AddAddress(attach.Mesh.Count.ToString() + ",NJS_MESHSET_SADX", attach.MeshName, desc.MeshsetOrPolyName, writer_split, writer_ida);
                        NJS_MESHSET[] mesharray = attach.Mesh.ToArray();
                        for (int u = 0; u < mesharray.Length; u++)
                        {
                            //Console.WriteLine("Adding mesh {0} of {1} ({2})", u, mesharray.Length, desc.MeshsetItemNames.Length);
                            if (mesharray[u].Poly != null && desc.MeshsetItemNames[u].PolyName != null)
                            {
                                int polycount = 0;
                                foreach (var poly in mesharray[u].Poly)
                                    polycount += poly.Indexes.Length;
                                if (mesharray[u].PolyType == Basic_PolyType.Strips)
                                    polycount+= mesharray[u].Poly.Count;
                                //Console.WriteLine("Adding poly");
                                AddAddress(polycount.ToString() + ",Sint16", mesharray[u].PolyName, desc.MeshsetItemNames[u].PolyName, writer_split, writer_ida);
                            }
                            if (mesharray[u].UV != null && desc.MeshsetItemNames[u].UVName != null)
                            {
                                //Console.WriteLine("Adding tex");
                                AddAddress(mesharray[u].UV.Length.ToString() + ",NJS_TEX", mesharray[u].UVName, desc.MeshsetItemNames[u].UVName, writer_split, writer_ida);
                            }
                            if (mesharray[u].PolyNormal != null && desc.MeshsetItemNames[u].PolyNormalName != null)
                            {
                                //Console.WriteLine("Adding polynormal");
                                AddAddress(mesharray[u].PolyNormal.Length.ToString() + ",NJS_VECTOR", mesharray[u].PolyNormalName, desc.MeshsetItemNames[u].PolyNormalName, writer_split, writer_ida);
                            }
                            if (mesharray[u].VColor != null && desc.MeshsetItemNames[u].VColorName != null)
                            {
                                //Console.WriteLine("Adding vc");
                                AddAddress(mesharray[u].VColor.Length.ToString() + ",NJS_COLOR", mesharray[u].VColorName, desc.MeshsetItemNames[u].VColorName, writer_split, writer_ida);
                            }
                        }
                    }
                }
                else if (mdl.Attach is ChunkAttach)
                {
                    AddAddress("NJS_CNK_ATTACH", mdl.Attach.Name, desc.AtachName, writer_split, writer_ida);
                    ChunkAttach attach = (ChunkAttach)mdl.Attach;
                    if (attach.Vertex != null)
                    {
                        List<byte> chunks = new List<byte>();
                        foreach (VertexChunk item in attach.Vertex)
                            chunks.AddRange(item.GetBytes());
                        chunks.AddRange(BitConverter.GetBytes((int)0));
                        byte[] cb = chunks.ToArray();
                        AddAddress((cb.Length / 4).ToString() + ",Sint32", attach.VertexName, desc.VertexName, writer_split, writer_ida);
                    }
                    if (attach.Poly != null)
                    {
                        List<byte> chunks = new List<byte>();
                        foreach (PolyChunk item in attach.Poly)
                            chunks.AddRange(item.GetBytes());
                        chunks.AddRange(BitConverter.GetBytes((short)0));
                        byte[] cb = chunks.ToArray();
                        AddAddress((cb.Length / 2).ToString() + ",Sint16", attach.PolyName, desc.MeshsetOrPolyName, writer_split, writer_ida);
                    }
                }
            }
            if (mdl.Children != null && mdl.Children.Count > 0)
            {
                NJS_OBJECT[] childarray = mdl.Children.ToArray();
                //Console.WriteLine("Child array length: orig {0}, label {1}", childarray.Length, desc.ChildNames.Length);
                for (int u = 0; u < childarray.Length; u++)
                {
                    //Console.WriteLine("Child of {0}: {1} ( {2} ) is {3}", mdl.Name, childarray[u].Name, u.ToString(), desc.ChildNames[u]);
                    ExportAddr(childarray[u], path, writer_split, writer_ida, desc.ChildNames[u], labelindex);
                }
            }
            if (mdl.Parent == null && mdl.Sibling != null)
            {
                ExportAddr(mdl.Sibling, path, writer_split, writer_ida, desc.SiblingName, labelindex);
            }
        }

        static int GetMdataType(NJS_MOTION mot)
        {
            bool hasPos = false;
            bool hasRot = false;
            bool hasScl = false;
            bool hasVec = false;
            bool hasVert = false;
            bool hasNorm = false;
            bool hasTarg = false;
            bool hasRoll = false;
            bool hasAng = false;
            bool hasCol = false;
            bool hasInt = false;
            bool hasSpot = false;
            bool hasPnt = false;
            AnimFlags flags = 0;
            int numpairs = 0;
            foreach (KeyValuePair<int, AnimModelData> model in mot.Models)
            {
                if (model.Value.Position.Count > 0)
                {
                    hasPos = true;
                }
                if (model.Value.Rotation.Count > 0)
                {
                    hasRot = true;
                }
                if (model.Value.Scale.Count > 0)
                {
                    hasScl = true;
                }
                if (model.Value.Vector.Count > 0)
                {
                    hasVec = true;
                }
                if (model.Value.Vertex.Count > 0)
                {
                    hasVert = true;
                }
                if (model.Value.Normal.Count > 0)
                {
                    hasNorm = true;
                }
                if (model.Value.Target.Count > 0)
                {
                    hasTarg = true;
                }
                if (model.Value.Roll.Count > 0)
                {
                    hasRoll = true;
                }
                if (model.Value.Angle.Count > 0)
                {
                    hasAng = true;
                }
                if (model.Value.Color.Count > 0)
                {
                    hasCol = true;
                }
                if (model.Value.Intensity.Count > 0)
                {
                    hasInt = true;
                }
                if (model.Value.Spot.Count > 0)
                {
                    hasSpot = true;
                }
                if (model.Value.Point.Count > 0)
                {
                    hasPnt = true;
                }
            }
            if (hasPos)
            {
                flags |= AnimFlags.Position;
                numpairs++;
            }
            if (hasRot)
            {
                flags |= AnimFlags.Rotation;
                numpairs++;
            }
            if (hasScl)
            {
                flags |= AnimFlags.Scale;
                numpairs++;
            }
            if (hasVec)
            {
                flags |= AnimFlags.Vector;
                numpairs++;
            }
            if (hasVert)
            {
                flags |= AnimFlags.Vertex;
                numpairs++;
            }
            if (hasNorm)
            {
                flags |= AnimFlags.Normal;
                numpairs++;
            }
            if (hasTarg)
            {
                flags |= AnimFlags.Target;
                numpairs++;
            }
            if (hasRoll)
            {
                flags |= AnimFlags.Roll;
                numpairs++;
            }
            if (hasAng)
            {
                flags |= AnimFlags.Angle;
                numpairs++;
            }
            if (hasCol)
            {
                flags |= AnimFlags.Color;
                numpairs++;
            }
            if (hasInt)
            {
                flags |= AnimFlags.Intensity;
                numpairs++;
            }
            if (hasSpot)
            {
                flags |= AnimFlags.Spot;
                numpairs++;
            }
            if (hasPnt)
            {
                flags |= AnimFlags.Point;
                numpairs++;
            }
            switch (flags)
            {
                case AnimFlags.Position:
                case AnimFlags.Rotation:
                    hasPos = true;
                    hasRot = true;
                    flags = AnimFlags.Position | AnimFlags.Rotation;
                    numpairs = 2;
                    break;
                case AnimFlags.Scale:
                    hasRot = true;
                    flags |= AnimFlags.Rotation;
                    numpairs++;
                    break;
                case AnimFlags.Vertex:
                case AnimFlags.Normal:
                    hasVert = true;
                    hasNorm = true;
                    flags = AnimFlags.Vertex | AnimFlags.Normal;
                    numpairs = 2;
                    break;
            }
            if (numpairs == 0)
                numpairs = 2;
            return numpairs;
        }

        static void ExportAddr(NJS_MOTION mot, string path, TextWriter writer_split, TextWriter writer_ida, string label, Dictionary<string, int> labelindex)
        {
            AddAddress("NJS_MOTION", mot.Name, label, writer_split, writer_ida);
            if (!labelindex.ContainsKey(label))
            {
                Console.WriteLine("Label {0} not found", label);
                return;
            }
            bool succ = labelindex.TryGetValue(label, out int indx);
            if (!succ)
            {
                Console.WriteLine("Name {0} missing in the address list", label);
                return;
            }
            Label_MOTION desc = IniSerializer.Deserialize<Label_MOTION>(Path.Combine(path, indx.ToString() + ".txt"));
            if (mot.Models != null)
            {
                AddAddress(mot.ModelParts.ToString() + ",NJS_MDATA" + GetMdataType(mot).ToString(), mot.MdataName, desc.MdataName, writer_split, writer_ida);
                if (mot.Models.Count == 0) return;
                foreach (var item in mot.Models)
                {
                    Label_MKEY mkey = desc.MkeyNames[item.Key];
                    if (item.Value.Position.Count > 0)
                        AddAddress(item.Value.Position.Count.ToString() + ",NJS_MKEY_F", item.Value.PositionName, mkey.PositionName, writer_split, writer_ida);
                    if (item.Value.Rotation.Count > 0)
                    {
                        if (mot.ShortRot == true)
                            AddAddress(item.Value.Rotation.Count.ToString() + ",NJS_MKEY_SA", item.Value.RotationName, mkey.RotationName, writer_split, writer_ida);
                        else
                            AddAddress(item.Value.Rotation.Count.ToString() + ",NJS_MKEY_A", item.Value.RotationName, mkey.RotationName, writer_split, writer_ida);
                    }
                    if (item.Value.Scale.Count > 0)
                        AddAddress(item.Value.Scale.Count.ToString() + ",NJS_MKEY_F", item.Value.ScaleName, mkey.ScaleName, writer_split, writer_ida);
                    if (item.Value.Vertex.Count > 0)
                    {
                        AddAddress(item.Value.Vertex.Count.ToString() + ",NJS_MKEY_P", item.Value.VertexName, mkey.VertexName, writer_split, writer_ida);
                        int cunt = 0;
                        foreach (KeyValuePair<int, Vertex[]> vkey in item.Value.Vertex)
                        {
                            Console.WriteLine("Adding {0} to {1}, index {2}", mkey.VertexItemNames[cunt], item.Value.VertexItemName[cunt], cunt);
                            AddAddress(vkey.Value.Length.ToString() + ",NJS_VECTOR", item.Value.VertexItemName[cunt], mkey.VertexItemNames[cunt], writer_split, writer_ida);
                            cunt++;
                        }
                    }
                    if (item.Value.Normal.Count > 0)
                    {
                        AddAddress(item.Value.Normal.Count.ToString() + ",NJS_MKEY_P", item.Value.NormalName, mkey.NormalName, writer_split, writer_ida);
                        int cunt = 0;
                        foreach (KeyValuePair<int, Vertex[]> nkey in item.Value.Normal)
                        {
                            AddAddress(nkey.Value.Length.ToString() + ",NJS_VECTOR", item.Value.NormalItemName[cunt], mkey.NormalItemNames[cunt], writer_split, writer_ida);
                            cunt++;
                        }
                    }
                    if (item.Value.Vector.Count > 0)
                        Console.WriteLine("For fuck's sake!");
                    //AddAddress(item.Value.VectorName, mkey.VectorName, writer_split, writer_ida);
                    if (item.Value.Angle.Count > 0)
                        Console.WriteLine("For fuck's sake!");
                    //AddAddress(item.Value.AngleName, mkey.AngleName, writer_split, writer_ida);
                    if (item.Value.Roll.Count > 0)
                        Console.WriteLine("For fuck's sake!");
                    //AddAddress(item.Value.RollName, mkey.RollName, writer_split, writer_ida);
                    if (item.Value.Intensity.Count > 0)
                        Console.WriteLine("For fuck's sake!");
                    //AddAddress(item.Value.IntensityName, mkey.IntensityName, writer_split, writer_ida);
                    if (item.Value.Point.Count > 0)
                        Console.WriteLine("For fuck's sake!");
                    //AddAddress(item.Value.PointName, mkey.PointName, writer_split, writer_ida);
                    if (item.Value.Target.Count > 0)
                        Console.WriteLine("For fuck's sake!");
                    //AddAddress(item.Value.TargetName, mkey.TargetName, writer_split, writer_ida);
                    if (item.Value.Color.Count > 0)
                        Console.WriteLine("For fuck's sake!");
                    //AddAddress(item.Value.ColorName, mkey.ColorName, writer_split, writer_ida);
                    if (item.Value.Spot.Count > 0)
                        Console.WriteLine("For fuck's sake!");
                    //AddAddress(item.Value.SpotName, mkey.SpotName, writer_split, writer_ida);
                }
            }
        }

        static void ExportAddr(NJS_ACTION action, string path, TextWriter writer_split, TextWriter writer_ida, string label, Dictionary<string, int> labelindex)
        {
            //Console.WriteLine("\nAction name: {0}, motion name: {1}\n", action.Name, action.Animation.Name);
            AddAddress("NJS_ACTION", action.Name, label, writer_split, writer_ida);
            if (!labelindex.ContainsKey(label))
            {
                Console.WriteLine("Label {0} not found", label);
                return;
            }
            bool succ = labelindex.TryGetValue(label, out int indx);
            if (!succ)
            {
                Console.WriteLine("Name {0} missing in the address list", label);
                return;
            }
            Label_ACTION desc = IniSerializer.Deserialize<Label_ACTION>(Path.Combine(path, indx.ToString() + ".txt"));
            if (action.Model != null)
            {
                ExportAddr(action.Model, path, writer_split, writer_ida, desc.ObjectName, labelindex);
            }
            if (action.Animation != null)
            {
                ExportAddr(action.Animation, path, writer_split, writer_ida, desc.MotionName, labelindex);
            }
            //Console.WriteLine("Action nameS: {0}, motion nameS: {1}", label, desc.MotionName);
        }

        static void ExportAddr(LandTable land, string path, TextWriter writer_split, TextWriter writer_ida, string label, Dictionary<string, int> labelindex)
        {
            AddAddress("OBJ_LANDTABLE", land.Name, label, writer_split, writer_ida);
            if (!labelindex.ContainsKey(label))
            {
                Console.WriteLine("Label {0} not found", label);
                return;
            }
            bool succ = labelindex.TryGetValue(label, out int indx);
            if (!succ)
            {
                Console.WriteLine("Name {0} missing in the address list", label);
                return;
            }
            Label_LANDTABLE desc = IniSerializer.Deserialize<Label_LANDTABLE>(Path.Combine(path, indx.ToString() + ".txt"));
            if (land.COL != null && land.COL.Count > 0)
            {
                AddAddress(land.COL.Count.ToString() + ",OBJ_LANDENTRY", land.COLName, desc.COLListName, writer_split, writer_ida);
                COL[] colarray = land.COL.ToArray();
                for (int u = 0; u < colarray.Length; u++)
                {
                    ExportAddr(colarray[u].Model, path, writer_split, writer_ida, desc.ColItemNames[u], labelindex);
                }
            }
            if (land.Anim != null && land.Anim.Count > 0)
            {
                AddAddress(land.Anim.Count.ToString() + ",OBJ_MOTLANDENTRY", land.AnimName, desc.GeoAnimListName, writer_split, writer_ida);
                GeoAnimData[] geoanimarray = land.Anim.ToArray();
                for (int u = 0; u < geoanimarray.Length; u++)
                {
                    NJS_ACTION action = new NJS_ACTION(geoanimarray[u].Model, geoanimarray[u].Animation);
                    action.Name = geoanimarray[u].ActionName;
                    ExportAddr(action, path, writer_split, writer_ida, desc.GeoAnimActionNames[u], labelindex);
                }
            }
        }

        static string MakeRelativePath(string workingDirectory, string fullPath)
        {
            string result = string.Empty;
            int offset;

            // this is the easy case.  The file is inside of the working directory.
            if (fullPath.StartsWith(workingDirectory))
            {
                return fullPath.Substring(workingDirectory.Length + 1);
            }

            // the hard case has to back out of the working directory
            string[] baseDirs = workingDirectory.Split(new char[] { ':', '\\', '/' });
            string[] fileDirs = fullPath.Split(new char[] { ':', '\\', '/' });

            // if we failed to split (empty strings?) or the drive letter does not match
            if (baseDirs.Length <= 0 || fileDirs.Length <= 0 || baseDirs[0] != fileDirs[0])
            {
                // can't create a relative path between separate harddrives/partitions.
                return fullPath;
            }

            // skip all leading directories that match
            for (offset = 1; offset < baseDirs.Length; offset++)
            {
                if (baseDirs[offset] != fileDirs[offset])
                    break;
            }

            // back out of the working directory
            for (int i = 0; i < (baseDirs.Length - offset); i++)
            {
                result += "..\\";
            }

            // step into the file path
            for (int i = offset; i < fileDirs.Length - 1; i++)
            {
                result += fileDirs[i] + "\\";
            }

            // append the file
            result += fileDirs[fileDirs.Length - 1];

            return result;
        }

        static void AddToAddressList(int address, List<int> list)
        {
            if (list.Contains(address))
                Console.WriteLine("Address {0} already added", address.ToString("X"));
            else
            {
                list.Add(address);
                Console.WriteLine("Adding {0}", address.ToString("X"));
            }
        }

        static void AddToAddressList(List<int> addresses, List<int> list)
        {
            foreach (int item in addresses)
            {
                if (list.Contains(item))
                    Console.WriteLine("Address {0} already added", item.ToString("X"));
                else
                    list.Add(item);
            }
        }

        static List<int> GetAddresses(BasicAttach att)
        {
            List<int> result = new List<int>();
            AddToAddressList(GetAddressFromLabel(att.Name), result);
            if (att.Material != null && att.Material.Count > 0)
                AddToAddressList(GetAddressFromLabel(att.MaterialName), result);
            if (att.Vertex != null && att.Vertex.Length > 0)
                AddToAddressList(GetAddressFromLabel(att.VertexName), result);
            if (att.Normal != null && att.Normal.Length > 0)
                AddToAddressList(GetAddressFromLabel(att.NormalName), result);
            if (att.MeshName != null && att.Mesh.Count > 0)
            {
                AddToAddressList(GetAddressFromLabel(att.MeshName), result);
                foreach (NJS_MESHSET mesh in att.Mesh)
                {
                    if (mesh.Poly != null && mesh.Poly.Count > 0)
                        AddToAddressList(GetAddressFromLabel(mesh.PolyName), result);
                    if (mesh.UV != null && mesh.UV.Length > 0)
                        AddToAddressList(GetAddressFromLabel(mesh.UVName), result);
                    if (mesh.VColor != null && mesh.VColor.Length > 0)
                        AddToAddressList(GetAddressFromLabel(mesh.VColorName), result);
                    if (mesh.PolyNormal != null && mesh.PolyNormal.Length > 0)
                        AddToAddressList(GetAddressFromLabel(mesh.PolyNormalName), result);
                }
            }
            return result;
        }

        static List<int> GetAddresses(NJS_OBJECT obj)
        {
            List<int> result = new List<int>();
            AddToAddressList(GetAddressFromLabel(obj.Name), result);
            if (obj.Attach != null && obj.Attach is BasicAttach att)
            {
                AddToAddressList(GetAddresses(att), result);
            }
            if (obj.Children != null)
            {
                foreach (NJS_OBJECT child in obj.Children)
                    AddToAddressList(GetAddresses(child), result);
            }
            return result;
        }

        static List<int> GetAddresses(NJS_MOTION mot)
        {
            List<int> result = new List<int>();
            AddToAddressList(GetAddressFromLabel(mot.Name), result);
            AddToAddressList(GetAddressFromLabel(mot.MdataName), result);
            foreach (var item in mot.Models)
            {
                if (item.Value.Position.Count > 0)
                    AddToAddressList(GetAddressFromLabel(item.Value.PositionName), result);
                if (item.Value.Rotation.Count > 0)
                    AddToAddressList(GetAddressFromLabel(item.Value.RotationName), result);
                if (item.Value.Scale.Count > 0)
                    AddToAddressList(GetAddressFromLabel(item.Value.ScaleName), result);
                if (item.Value.Vertex.Count > 0)
                {
                    AddToAddressList(GetAddressFromLabel(item.Value.VertexName), result);
                    for (int i = 0; i < item.Value.VertexItemName.Length; i++)
                        AddToAddressList(GetAddressFromLabel(item.Value.VertexItemName[i]), result);
                }
                if (item.Value.Normal.Count > 0)
                {
                    AddToAddressList(GetAddressFromLabel(item.Value.NormalName), result);
                    for (int i = 0; i < item.Value.NormalItemName.Length; i++)
                        AddToAddressList(GetAddressFromLabel(item.Value.NormalItemName[i]), result);
                }
            }
            return result;
        }

        static void AddressesFromLabels(string filePath, string filePath_relative, TextWriter writer)
        {
            List<int> addressList = new List<int>();
            int structsize;
            string ext = Path.GetExtension(filePath);
            switch (ext.ToLowerInvariant())
            {
                case ".sa1mdl":
                    NJS_OBJECT obj = new ModelFile(filePath).Model;
                    AddToAddressList(GetAddresses(obj), addressList);
                    structsize = 52;
                    break;
                case ".saanim":
                    NJS_MOTION mot = NJS_MOTION.Load(filePath);
                    AddToAddressList(GetAddresses(mot), addressList);
                    structsize = 12;
					break;
				default:
                    Console.WriteLine("Unknown extension for file: {0}", filePath);
                    return;
			}
            int listmin = addressList.Min();
            int listmax = addressList.Max() + structsize - 1;
            writer.WriteLine("{0}={1}-{2}", filePath_relative.Replace(ext, ""), listmin.ToString("X8"), listmax.ToString("X8"));
        }
    }
}
