using SAModel;
using SplitTools;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;

namespace LabelGen
{
    partial class Program
    {
        // Gets the address from a label, e.g. "01020304" out of "object_01020304" as an integer
        static int GetAddressFromLabel(string label)
        {
            if (label == null || label.Length < 11) //Smallest possible autogenerated name like "uv_..."
                return 0;
            int addr = 0;
            bool succ = int.TryParse(label.Substring(label.Length - 8, 8), NumberStyles.HexNumber, null, out addr);
            if (succ == false)
                Console.WriteLine("Name {0} couldn't be parsed", label);
            return addr;
        }

        // Returns a generated label based on the object name, a new prefix and an array ID (for meshset items etc.)
        public static string AddLabelWithID(string name_addr, string label_object, string newprefix, int index, Dictionary<int, string> output)
        {
            // name_addr is an address-based label such as "attach_00000000"
            // label_object is an NJS_OBJECT label such as "object_myobject"
            // newprefix is the new prefix for the label such as "model"
            // output is a labels list
            // return value is the complete label such as "attach_myobject"
            string result = ReplaceFirst(label_object, "object", newprefix + "_" + index.ToString());
            int addr = GetAddressFromLabel(name_addr);
            if (addr != 0 && !output.ContainsKey(addr))
                output.Add(addr, result);
            Console.WriteLine("{0}: {1}", name_addr, result);
            return result;
        }

        // Returns a generated label based on the object name and a new prefix
        static string AddLabel(string name_addr, string label_object, string newprefix, Dictionary<int, string> output)
        {
            // name_addr is an address-based label such as "attach_00000000"
            // label_object is an NJS_OBJECT label such as "object_myobject"
            // newprefix is the new prefix for the label such as "model"
            // output is a labels list
            // return value is the complete label such as "attach_myobject"
            string result = ReplaceFirst(label_object, "object", newprefix);
            int addr = GetAddressFromLabel(name_addr);
            if (addr != 0 && !output.ContainsKey(addr))
                output.Add(addr, result);
            Console.WriteLine("{0}: {1}", name_addr, result);
            return result;
        }

        // Generate labels for OBJECT based on object name
        static void GenerateLabels(NJS_OBJECT obj, string label, Dictionary<int, string> output)
        {
            Console.WriteLine("Object: {0}", label);
            int addr = GetAddressFromLabel(obj.Name);
            if (addr != 0 && !output.ContainsKey(addr))
                output.Add(addr, label);
            obj.Name = label;
            if (obj.Attach != null)
            {
                obj.Attach.Name = AddLabel(obj.Attach.Name, label, "model", output);
                if (obj.Attach is BasicAttach batt)
                {
                    batt.NormalName = AddLabel(batt.NormalName, label, "normal", output);
                    batt.VertexName = AddLabel(batt.VertexName, label, "point", output);
                    batt.MeshName = AddLabel(batt.MeshName, label, "meshset", output);
                    batt.MaterialName = AddLabel(batt.MaterialName, label, "material", output);
                    if (batt.Mesh != null && batt.Mesh.Count > 0)
                    {
                        foreach (NJS_MESHSET mesh in batt.Mesh)
                        {
                            int meshID = batt.Mesh.IndexOf(mesh);
                            Console.WriteLine("Mesh {0}", meshID);
                            if (mesh.Poly != null)
                            {
                                mesh.PolyName = AddLabelWithID(mesh.PolyName, label, "pgS", meshID, output);
                            }
                            if (mesh.UV != null)
                            {
                                mesh.UVName = AddLabelWithID(mesh.UVName, label, "vuvS", meshID, output);
                            }
                            if (mesh.VColor != null)
                            {
                                mesh.VColorName = AddLabelWithID(mesh.VColorName, label, "vcS", meshID, output);
                            }
                            if (mesh.PolyNormal != null)
                            {
                                mesh.PolyNormalName = AddLabelWithID(mesh.PolyNormalName, label, "pnS", meshID, output);
                            }
                        }
                    }
                }
            }
        }

        // Gets the name of an OBJECT from the label of an NJS_MKEY
        static string GetNodeNameFromMkey(AnimModelData mkey, string motname)
        {
            string nodefull = "";
            if (mkey.PositionName != null)
                nodefull = mkey.PositionName;
            if (mkey.RotationName != null)
                nodefull = mkey.RotationName;
            if (mkey.ScaleName != null)
                nodefull = mkey.ScaleName;
            return nodefull.Remove(0, 4 + motname.Length + 1); // Remove "pos_" and "motionname_"
        }

        // Checks whether a label ends with a hex number (e.g. "object_00000000")
        private static bool LabelIsNumerical(string label)
        {
            if (label == null || label.Length < 8)
                return false;
            string number = label.Substring(label.Length - 8, 8);
            bool res = int.TryParse(number, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out int test);
            return res;
        }

        // Adds missing UV labels to some Chaos models
        static void FixUVLabels(NJS_OBJECT obj)
        {
            if (obj.Attach != null && obj.Attach is BasicAttach batt)
            {
                for (int i = 0; i < batt.Mesh.Count; i++)
                    if (batt.Mesh[i].UVName != null && LabelIsNumerical(batt.Mesh[i].UVName))
                        batt.Mesh[i].UVName = batt.Mesh[i].PolyName.Replace("pg", "vuv");
            }
        }

        // Generate labels for OBJECT based on another OBJECT
        static void GenerateLabels(NJS_OBJECT[] src, NJS_OBJECT dst, Dictionary<int, string> output)
        {
            Console.WriteLine("M:{0}", src.Length);
            foreach (NJS_OBJECT obj in src)
            {
                foreach (NJS_OBJECT obj2 in obj.GetObjects())
                FixUVLabels(obj2);
            }
            List<LabelOBJECT> list = LabelOBJECT.ExportLabels(src[0]);
            LabelOBJECT.OutputLabelList(dst, list, output);
            LabelOBJECT.ImportLabels(dst, list);
            foreach (var item in output)
                Console.WriteLine(item.Key.ToString("X") + "=" + item.Value);
        }

        // Generate labels for OBJECT based on labels for MOTION (takes an array of MOTION)
        static void GenerateLabels(NJS_MOTION[] mot, NJS_OBJECT obj, string objname, Dictionary<int, string> output)
        {
            // Build motion names
            string[] motionnames = new string[mot.Length];
            for (int i = 0; i < mot.Length; i++)
            {
                motionnames[i] = mot[i].Name.Remove(0, 7); // Remove "motion_"
                Console.WriteLine("Motion {0}: {1}", i, motionnames[i]);
            }
            // Create a nodes list
            int nodecount = obj.GetObjectsAnimated().Count();
            Console.WriteLine("Nodes: {0}, animated nodes: {1}", obj.GetObjects().Count(), nodecount);
            // Loop through motions and assign node names
            Dictionary<int, string> foundnodes = new();
            for (int n = 0; n < nodecount; n++)
            {
                for (int m = 0; m < mot.Length; m++)
                {
                    //Console.WriteLine(motionnames[m]);
                    foreach (KeyValuePair<int, AnimModelData> mkey in mot[m].Models)
                    {
                        //Console.WriteLine(mkey.Key);
                        if (!foundnodes.ContainsKey(n) && mkey.Key == n)
                        {
                            string nodename = "object_" + objname + "_" + GetNodeNameFromMkey(mkey.Value, motionnames[m]);
                            foundnodes.Add(n, nodename);
                            //Console.WriteLine("Node {0}: {1}", n, nodename);
                        }
                    }
                }
            }
            for (int z = 0; z < nodecount; z++)
            {
                if (foundnodes.ContainsKey(z))
                {
                    GenerateLabels(obj.GetObjects()[z], foundnodes[z], output);
                    Console.WriteLine("Node {0}: {1}", z, foundnodes[z]);
                }
                else
                    Console.WriteLine("Node {0}: not found", z);
            }
            Console.WriteLine("Recovered {0} of {1} nodes", foundnodes.Count, nodecount);
        }

        // Generate labels for MOTION based on labels for OBJECT
        static void GenerateLabels(NJS_MOTION mot, string motname, NJS_OBJECT obj, Dictionary<int, string> output)
        {
            Console.WriteLine("Motion for object: {0}", obj.Name);
            string genname = obj.Name;
            mot.Name = AddLabel(mot.Name, genname, "motion_" + motname, output);
            mot.MdataName = AddLabel(mot.MdataName, genname, "mdata_" + motname, output);
            Console.WriteLine("Motion: {0}", mot.Name);
            Console.WriteLine("Mdata: {0}", mot.MdataName);
            int nodeid = 0;
            foreach (KeyValuePair<int, AnimModelData> model in mot.Models)
            {
                string nodename = obj.GetObjectsAnimated()[model.Key].Name;
                if (model.Value.Position.Count > 0)
                {
                    model.Value.PositionName = AddLabel(model.Value.PositionName, nodename, "pos_" + motname, output);
                    Console.WriteLine("Pos: {0}", model.Value.PositionName);
                }
                if (model.Value.Rotation.Count > 0)
                {
                    model.Value.RotationName = AddLabel(model.Value.RotationName, nodename, "rot_" + motname, output);
                    Console.WriteLine("Rot: {0}", model.Value.RotationName);
                }
                if (model.Value.Scale.Count > 0)
                {
                    model.Value.ScaleName = AddLabel(model.Value.ScaleName, nodename, "scl_" + motname, output);
                    Console.WriteLine("Scl: {0}", model.Value.ScaleName);
                }
                if (model.Value.Vector.Count > 0)
                {
                    model.Value.VectorName = AddLabel(model.Value.VectorName, nodename, "vct_" + motname, output);
                    Console.WriteLine("Vect: {0}", model.Value.VectorName);
                }
                /*
                if (model.Value.Vertex.Count > 0)
                {
                    model.Value.VertexName = MakeLabel(nodename, "vlist_" + motname);
                    for (int frame = 0; frame < model.Value.Vertex.Count; frame++)
                    {
                        int[] keyframes = model.Value.Vertex.Keys.ToArray();
                        model.Value.VertexItemName[frame] = MakeLabel(nodename, "vert" + keyframes[frame].ToString() + "_" + motname);
                    }
                }
                if (model.Value.Normal.Count > 0)
                {
                    model.Value.ScaleName = MakeLabel(nodename, "vert" + model.Key.ToString() + "_" + motname);
                }
                */
                Console.WriteLine();
            }

        }

        // From https://stackoverflow.com/a/8809437
        public static string ReplaceFirst(string text, string search, string replace)
        {
            int pos = text.IndexOf(search);
            if (pos < 0)
            {
                return text;
            }
            return text.Substring(0, pos) + replace + text.Substring(pos + search.Length);
        }
    }
}